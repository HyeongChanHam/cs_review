
목차
0. [자료구조(Data Structure)](면접 준비 - 데이터구조#0. 자료구조(Data Structure))
1. [선형리스트] [[면접 준비_데이터구조#0. 자료구조(Data Structure)]]
2. 
3. 
# 0. 자료구조(Data Structure)

## 정의
- 자료를 효율적으로 이용할 수 있도록 컴퓨터에 저장하는 방법

## 목적
-  신중히 선택한 자료구조는 보다 효율적인 알고리즘을 사용할 수 있게 함.

## 분류
- 선형구조 / 비선형구조
![[Pasted image 20240414163053.png]]

### 선형 자료 구조 (Linear Data Structure)
정의: 자료를 구성하는 원소들을 순차적으로 나열시킨 형태
예시: 리스트, 스택, 큐, 덱
특징
- 데이터가 **순차적**으로 배열되어 있음
- 단일 레벨로 표현되기 때문에 단일 실행으로 모든 요소를 순회 가능
- 메모리가 선형 방식으로 배열되기 때문에 구현하기 쉽다.
- 저장되는 자료의 전후관계가 1:1 이다.


### 비선형 자료 구조 (Non-Linear Data Structure)
정의: 하나의 자료 뒤에 여러 개의 자료가 존재할 수 있는 형태
예시: 그래프, 트리
특징
- 데이터가 **계층적**으로 연결되어 있다.
- 계층적이기 때문에 단일 실행으로 모든 요소를 순회할 수 없고, 여러 번 실행해야 한다.
- 선형 데이터 구조에 비해 구현하기 어렵다.
- 저장되는 자료의 전후관계가 1:N 또는 N:N이다.

# 1. 선형리스트 (Linear List), 배열 (Array)

## 정의
- 연속된 메모리 공간에 순차적으로 저장된 데이터 모음

* 배열을 구성하는 각각의 값을 요소(element)라고 함
* 배열에서의 위치를 가리키는 숫자는 인덱스(index)라고 함


## 배열의 시간복잡도 (Time Complexity)

| Operation | average case | worst case |
| --------- | ------------ | ---------- |
| 읽기        | O(1)         | O(1)       |
| 삽입        | O(n)         | O(n)       |
| 삭제        | O(n)         | O(n)       |
| 검색        | O(n)         | O(n)       |

읽기: 인덱스 k 원소를 출력
삽입: 데이터 d를 인덱스 k에 추가
삭제: 인덱스 k 원소를 삭제
검색: 데이터 d가 어느 인덱스에 있는지 찾는거


## 특징
- 배열의 각 요소에 접근하는 시간은 O(1)로 모두 동일하다.
	- 기본 위치 + 오프셋(요소크기 * index) 연산으로 모든 요소에 접근 가능
- 연속된 메모리에 단일 블록화하여 데이터를 저장한다.
	- 낭비되는 공간이 거의 없다.
	- 요소 개수가 많아지면 메모리 할당이 불가능할 수도 있다.
- 실제 메모리 상에서 물리적으로 데이터가 순차적으로 저장되기 때문에, 데이터에 순서가 있다.
- index가 존재해서 indexing, slicing이 가능하다.
	- indexing: index를 사용해 특정 요소를 리스트로부터 읽어들이는 것
	- slicing: 요소에 특정 부분을 따로 분리해 조작하는 것

## 장점
- 인덱스를 이용한 접근이 가능하기 때문에 **모든 요소에 빠르게 접근**할 수 있다.
- 기록 밀도가 1이기 때문에 공간 낭비가 적다.
	- 링크드 리스트, 그래프 등은 데이터 외에 포인터 등의 부가정보를 가지기 때문에 기록밀도가 1이 안되지만, 배열은 부가정보 없이 데이터만 저장하기 때문에 기록밀도가 1이다.
- 간단하고 사용하기 쉽다.

## 단점
- 배열을 선언한 후에는 할당 된 정적 메모리 때문에 크기를 변경할 수 없다.
- 중간에 특정 요소를 삽입 및 삭제하는 경우 항상 메모리가 순차적으로 이어져 있어야 하기 때문에 삽입 및 삭제된 요소로부터 위에 있는 모든 요소들을 이동시켜주어야 한다.
	- 그래서 삽입 및 삭제에 비용이 많이 든다.
- 배열의 크기가 대부분 정적으로 결정되어서 삽입과 삭제가 동적으로 발생하는 상황에서 적절한 배열의 크기를 미리 결정하는 것이 어렵다.
	- 오버플로나 저장공간의 낭비를 초래할 수 있다.

## 배열 사용 예시
- 순차적인 데이터를 저장하며 값보다는 순서가 중요할 때
- 다차원 데이터를 다룰 때
- 어떤 특정 요소를 빠르게 읽어야 할 때
- 데이터 사이즈가 자주 바뀌지 않으며 요소가 자주 추가되거나 삭제되지 않을 때


# 2. 연결리스트 (Linked List)

## 정의
- 데이터와 포인터로 구성된 노드 간의 연결(link)를 이용해 리스트를 구현한 자료구조
## 특징
- 배열의 고정크기의 단점을 보완하기 위해 만들어졌다
- 배열과 달리 연속적인 메모리공간에 저장되어 있지 않기 때문에 **연결이 필요**하다.
- ![[Pasted image 20240414164523.png]]
	- Head: 리스트의 처음
	- 노드: 데이터 + 다음 노드를 가리키는 Next pointer
	- 각 노드는 next pointer를 사용하여 다음 노드와 연결됨
	- 마지막 노드는 null을 가리켜 리스트의 끝을 나타냄
- 노드의 next 부분에 다음 노드의 위치를 저장함으로서 선형적 데이터 자료구조를 가진다.
- 연결되어있는 구조이기 때문에 특정 위치의 데이터를 탐색하기 위해서는 첫 노드부터 탐색을 시작하며 **순차 접근으로만 가능**.
- 주소만 연결하면 되기 때문에 **삽입 / 삭제가 배열에 비해 빠르고 쉽다**.
- 불연속적 단위로 저장되기 때문에 **조회에 불리**, 포인터로 인해 **추가 저장공간이 필요**하다.

## 연결리스트의 시간복잡도 (Time Complexity)

| operation          | time                                              |
| ------------------ | ------------------------------------------------- |
| 시작 위치에 대한 삽입 / 삭제  | O(1)                                              |
| 마지막 위치에 대한 삽입 / 삭제 | O(1): 마지막 요소 위치를 아는 경우<br>O(n): 마지막 요소 위치를 모르는 경우 |
| 중간 위치에 대한 삽입 / 삭제  | search time + O(1)                                |
| 인덱싱                | O(n)                                              |
| 공간 낭비              | O(n)                                              |
|                    |                                                   |
|                    |                                                   |

## 장점
- 크기가 가변적이다
	- 메모리가 허용하는 만큼 커질 수 있다.
- 삽입 / 삭제가 쉽다.
	- 삽입 / 삭제 시에 데이터 이동이 필요 없다.

## 단점
- 렌덤 엑세스가 불가능하다.
	- 요소에 접근하려면 첫 번째 노드부터 순차적으로 접근해야 한다.
- 포인터를 위한 추가 메모리 공간이 필요하다.


## 종류
- 단일 연결 리스트 (Singly Linked List)
- 이중 연결 리스트 (Doubly Linked List)
	- 포인터 공간이 앞뒤로 두 개가 있다.
- 원형 연결 리스트 (Circular Linked List)
	- 마지막 노드가 처음 노드를 가리킨다.


# 3. 스택 (Stack)

## 정의
- 한쪽 끝에서만 자료를 넣거나 뺄 수 있는 선형 구조로 되어 있다.
- 

## 특징
![[Pasted image 20240414165327.png]]
- 스택은 LIFO (Last In First Out) 구조를 따른다.
	- 마지막으로 들어온 값이 처음으로 나가는 것
- 스택이 완전히 꽉 차면: Overflow
- 완전히 비어있으면: Underflow
- 삽입(Push), 제거(Pop)은 모두 Top이라는 스택의 한쪽 끝에서만 일어난다.


## 추상 자료형 (ADT, Abstract Data Type)
- push: 스택 맨 위에 항목을 삽입
- pop: 스택 맨 위에 항목 삭제
- peep or top: 스택의 맨 위(top)를 표시
- isEmpty: 스택이 비어있는지 확인
- isFull: 스택이 가득 차 있는지 확인
- getSize: 스택에 있는 요소 수를 반환


### push 작업


### pop 작업


## 시간복잡도
| operation    | Worst |
| ------------ | ----- |
| Access       | O(n)  |
| Search       | O(n)  |
| Input (push) | O(1)  |
| Delete (pop) | O(1)  |
- push, pop은 항상 Top에서만 일어나기 때문에 O(1)이다.


## 구현하는 방법
- 배열 사용
	- 장점: 구현하기 쉽다
	- 단점: 크기가 동적이 아니어서 런타임 시 필요에 따라 늘어나거나 줄어들지 않는다.
- 링크드 리스트 사용
	- 장점: 크기가 동적이다. 런타임 시 필요에 따라 크기가 확장 및 축소될 수 있다.
	- 단점: 포인터를 위한 추가 메모리 공간이 필요하다.

## 스택 사용 예시
- 재귀 알고리즘을 반복문을 통해 구현할 수 있게 해준다.
- 실행 취소 (undo)
- Backtracking
- 웹 브라우저 뒤로 가기
- 구문 분석
- postfix 표기법 연산
- 문자열의 역순 출력 등


# 4. 큐 (Queue)
## 정의
- 먼저 집어넣은 데이터가 먼저 나오는 FIFO (First In First Out) 구조로 저장하는 선형 자료구조

![[Pasted image 20240414170038.png]]
- 큐의 끝(Rear)에서 요소를 추가하는 작업을 enqueue라고함.
- 큐의 맨 앞(Front)에서 요소를 제거하는 작업을 dequeue라고 함
- 가득 찬 큐에 요소를 추가하려고 할 때 Overflow가 발생
- 빈 큐에서 요소를 제거하려고 할 때 underflow가 발생.


## 기본동작
- enqueue: 큐의 끝(rear)에 항목을 추가
- dequeue: 큐의 맨 앞(front)에 항목을 제거
- peek: 큐의 멘 앞(front)에 있는 항목을 반환
- isfull, isempty

## 시간복잡도
| Operation        | Worst |
| ---------------- | ----- |
| Access           | O(n)  |
| Search           | O(n)  |
| Insert (enqueue) | O(1)  |
| Delete (dequeue) | O(1)  |
|                  |       |

## 구현 방법
- 스택과 같다.

## 종류
1. 선형 큐 (Linear Queue)
	![[Pasted image 20240414170405.png]]
	- 기본적인 큐의 형태
	- 문제점
		- 배열로 구현시 크기가 제한됨
		- 빈 공간을 사용하려면 모든 자료를 꺼내거나 자료를 한 칸씩 옮겨야 한다
		- 많은 enqueue 및 dequeue 작업이 있는 경우, 어느 시점에서 큐가 비어있어도 자료를 삽입하지 못하는 경우 발생 **(왜??)**


1. 환형 큐 (Circular Queue)
	![[Pasted image 20240414170418.png]]
	- 선형 큐의 문제점을 보완 **(무슨문제??)**
	- 1차원 형태의 큐를 원형 (Circular)으로 구성하여 배열의 처음과 끝을 연결하여 만든다.

## 예시
- 어떤 작업/데이터를 순서대로 실행/사용하기 위해 **대기**시킬 때 사용.
	- CPU 스케쥴링, 디스크 스케쥴링
- 서로 다른 쓰레드 또는 프로세스 사이에서 자료를 주고 받을때 자료를 일시적으로 저장하는 용도로 많이 사용. (**비동기 전송**)
	- IO 버퍼, 파이프, 파일 IO


# 5. 트리 (Tree)

## 정의
- 노드들이 나무 가지처럼 연결된 비선형 계층적 자료구조

## 특징
- (나무를 거꾸로 뒤집어 놓은 모양임)
- 트리 내에 다른 하위 트리가 있고, 그 하위 트리 안에는 또 다른 하위 트리가 있는 **재귀적 자료구조**임.
- 컴퓨터의 directory 구조가 트리 구조의 대표적인 예.
- ![[Pasted image 20240414170959.png]]
- 노드 (Node)
	- 트리를 구성하고 있는 기본 요소
	- 노드에는 키 또는 값과 하위 노드에 대한 포인터를 가지고 있다.
- 간선 (Edge)
	- 노드와 노드 간의 연결선
- 루트 노드 (Root Node)
	- 트리 구조에서 부모가 없는 최상위 노드
- 부모 노드 (Parent Node)
	- 자식을 가진 노드
- 자식 노드 (Child node)
	- 부모 노드의 하위 노드
- 형제 노드 (Sibling node)
	- 같은 부모를 가지는 노드
- 외부 노드 (external node, outer node), 단말 노드 (terminal node), 리프 노드 (leaf node) (**처음 들어보는데??**)
	- 자식 노드가 없는 노드
- 내부 노드 (internal node, inner node), 비단말 노드 (non-terminal node), 가지 노드 (branch node)
	- 자식이 하나 이상 있는 노드
- 깊이 (depth)
	- 루트에서 어떤 노드까지의 간선 (edge) 수
	- 루트 노드의 깊이: 0
	- 위 그림에서 D의 깊이: 2
- 높이 (height)
	- 어떤 노드에서 리프 노드까지 가장 긴 경로의 간선(edge) 수
	- 리프 노드의 높이: 0
	- 위 그림에서 A 노드의 높이: 3
- ![[Pasted image 20240414171415.png]]

- Level: 루트에서 어떤 노드까지의 간선(edge) 수
- Degree
	- 노드의 자식 수
	- Leaf node의 degree: 0
	- 처음 그림에서 A의 degree: 2
- Path
	- 한 노드에서 다른 한 노드에 이르는 길 사이에 놓여있는 노드들의 순서
	- 처음 그림에서 A & H의 경로: A - B - D - H
- Path length
	- 해당 경로에 있는 총 노드의 수
	- A & H의 경로 길이: 4
- Size
	- 자신을 포함한 자손의 노드 수
	- 노드 B의 size: 6
- width
	- 레벨에 있는 노드 수
	- Level 2 width: 4
- Breadth
	- Leaf node의 수
	- 처음 그림에서 breadth: 5 (**내생각에, level이 다 같을 필요는 없다!**)
- Distance
	- 두 노드 사이의 최단 경로에 있는 간선(edge)의 수
	- D와 J의 distance: 3
- Order
	- 부모 노드가 가질 수 있는 최대 자식의 수
	- Order 3: 부모 노드는 최대 3명의 자식을 가질 수 있다는 뜻


## 특징
- **하나의 루트 노드**와 **0개 이상의 하위 트리**로 구성되어 있다.
- 데이터를 순차적으로 저장하지 않기 때문에 **비선형 자료구조**이다.
- 트리 내에 또다른 트리가 있는 **재귀적 자료구조**이다.
- 단순 순환(loop)을 갖지 않고, **연결된 무방향 그래프 구조**이다.
- 노드 간에 부모 자식 관계를 갖고 있는 **계층적 자료구조**이며 모든 자식 노드는 **하나의 부모 노드**만 갖는다.
- 노드가 n개인 트리는 항상 n-1개의 간선(edge)을 가진다.


## 트리가 아닌 경우
- ![[Pasted image 20240414172124.png]]
- 루트 노드가 2개(2, 8) 있어서 트리가 아니다.


- ![[Pasted image 20240414172144.png]]
- 노드 6에 2명의 부모 노드(8, 5)가 있고, cycle(2-8-6-5)이 형성되므로 트리가 아니다.


## 종류
1. 편향 트리 (skewed tree)
	- 모든 노드들이 자식을 하나만 가진 트리
	- 왼쪽 방향으로 자식을 하나씩만 가지면 left skewed tree, 오른쪽이면 right skewed tree, 치우치지 않을수도 있다.
	- ![[Pasted image 20240414172316.png]]

2. 이진 트리 (Binary Tree)
	- 각 노드의 차수 (자식 노드)가 2 이하인 트리 **(2 이하라면 자식이 1개더라도 여전히 이진트리?)**

4. 이진 탐색 트리 (Binary Search Tree, BST)
	- **순서화**된 이진 트리
	- 노드의 왼쪽 자식은 부모의 값보다 작은 값을 가져야 하며, 
	- 노드의 오른쪽 자식은 부모의 값보다 큰 값을 가져야 함.

5. m원 탐색 트리 (m-way search tree)
	- 최대 m개의 서브 트리를 갖는 탐색 트리
	- 이진 탐색 트리의 확장된 형태로, 높이를 줄이기 위해 사용함.

6. 균형 트리 (Balanced Tree, B-Tree)
	- m원 탐색 트리에서 높이 균형을 유지하는 트리
	- height-balanced m-way tree라고도 함.


## 사용 사례
- 계층적 데이터 저장
	- 파일 및 폴더 저장
- 효율적인 삽입, 삭제 및 검색을 위해 트리 구조 사용
- 힙 (Heap)
- 데이터베이스 인덱싱
	- B-Tree, B+Tree, AVL-Tree
- Trie
	- 사전을 저장하는 데 사용되는 특별한 종류의 트리이다.


## 이진 트리 (Binary Tree)
## 정의
- 모든 노드들이 둘 이하의 자식을 가진 트리
- ![[Pasted image 20240414173248.png]]

## 유형
- 전 이진트리 (Full Binary Tree / Strict Binary Tree)
- 완전 이진 트리 (Complete Binary Tree)
- 포화 이진 트리 (Perfect Binary Tree)
- 균형 이진 트리 (Balanced Binary Tree)
### 전 이진트리 (Full Binary Tree / Strict Binary Tree)
- 정의: 모든 노드가 0개 또는 2개의 자식 노드를 갖는 트리![[Pasted image 20240414173347.png]]

### 완전 이진 트리 (Complete Binary Tree)
- 정의: 마지막 레벨을 제외하고 모든 레벨이 완전히 채워져 있는 트리
	- 마지막 레벨은 꽉 차있지 않아도 되지만, 노드가 왼쪽에서 오른쪽으로 채워져야 한다.![[Pasted image 20240414173554.png]]

### 포화 이진 트리 (Perfect Binary Tree)
- 정의: 모든 내부 노드가 두 개의 자식 노드를 가지며 모든 잎(leaf) 노드가 동일한 깊이 또는 레벨을 가진다.![[Pasted image 20240414173653.png]]

### 균형 이진 트리 (Balanced Binary Tree)
- 정의: 왼쪽과 오른쪽 트리의 높이 차이가 모두 1만큼 나는 트리
- **AVL** 및 **Red-Black Tree**는 균형 이진 트리이다.![[Pasted image 20240414173840.png]]


## 이진트리 속성
- 이진트리의 레벨 x에서 노드의 최대 수는 $2^x$ 이다.![[Pasted image 20240414174023.png]]
- 높이가 h이고 하나의 노드를 가진 트리의 높이가 1이라면,
  최대 노드 수는 $2^h - 1$ 이고 높이가 0이라면 $2^{h+1} - 1$ 이다.![[Pasted image 20240414174353.png]]
  **그림에 height, depth 정의가 좀 이상한데..? 다시 보자**

- 잎(leaf) 노드의 높이가 1이라면 최소 높이는 $log_2{N+1}$  이다. 잎 노드의 높이가 0이면 $log_2{(N+1)}-1$이다. **높이의 정의 자체가 잎(leaf) 에서 0으로 되어 있지 않나..?**

$$2^h-1 = n$$
$$2^h = n+1$$
$$log_2{(2^h)}=log_2{(n+1)}$$
$$h=log_2{(n+1)}$$

- 전 이진트리 (Full Binary Tree / Strict Binary Tree)에서 리프 노드 수는 항상 자식이 두 개인 노드보다 하나 더 많다. **(왜??)**


## 이진트리 표현
- 배열(순차)로 표현
	- 루트 노드의 인덱스 i가 0인 경우
		- 노드 i에 왼쪽 자식은 $2\times i+1$ 번째 노드이다.
		- 노드 i에 오른쪽 자식은 $2\times i + 2$ 번째 노드이다.
		- 노드 i의 부모는 $(i-1) / 2$ 번째 노드이다.
	- 배열로 표현된 완전이진트리![[Pasted image 20240414175231.png]]
	- 배열 공간을 효율적으로 쓰고 있다.
	- ![[Pasted image 20240414175318.png]]
	- 편향트리(skewed Tree)인 경우 - 많은 공간이 낭비되고 있다.

- 링크드 리스트로 표현
- ![[Pasted image 20240414175353.png]]
	- 장점
		- 삽입 / 삭제가 쉽다.
		- 노드를 포인터로 연결하기 때문에 노드 수에 제한이 없다.
	- 단점
		- 배열보다는 접근 속도가 느리다.

## 이진 트리 용도
- 수식트리 (Expression Tree)
- 허프만 코딩 트리 (Huffman coding tree)
- 이진 검색 트리 (Binary Search Tree, BST)
- 우선 순위 큐 (PQ)


## 트리 순회 (Tree Traversal)
- 트리의 모든 노드들을 방문하는 과정
- 선형 자료 구조(링크드 리스트, 스택, 큐 등)는 순차적으로 요소에 접근하지만, 트리 자료구조는 다른 방식을 사용해야 한다.

## 종류
- 전위 순회 (Preorder)
- 중위 순회 (Inorder)
- 후위 순회 (Postorder)
-> 보통 재귀로 쉽게 구현 가능하다.


## 전위 순회 (Preorder Traversal)
- 깊이 우선 순회 (DFT, Depth-First Traversal)이라고도 한다.

### 용도
- 트리를 복사할 때
	- 트리 생성할 때 자식 노드보다 부모 노드가 먼저 생성되어야 하기 때문에!!
- 전위 표기법을 구하는데 주로 사용한다.

### 과정
1. Root 노드를 방문
2. 왼쪽 서브 트리를 전위 순회한다.
3. 오른쪽 서브 트리를 전위 순회한다.
4. ![[Pasted image 20240414175937.png]]
5. 전위 순회 결과: A-B-D-E-C-F-G

## 중위 순회 (Inorder Traversal)
- 왼쪽 오른쪽 대칭 순서로 순회를 하기 때문에 대칭 순회(symmetric traversal)라고도 한다.

### 용도
- 이진 탐색트리 (BST)에서 오름차순 또는 내림차순으로 값을 가져올 때 사용
	- 내림차순으로 값을 가져오기 위해서는 역순(오른쪽->root->왼쪽)으로 중위 순회 하면 됨

### 과정
1. 왼쪽 서브 트리를 중위 순회 한다.
2. Root 노드를 방문
3. 오른쪽 서브 트리를 중위 순회 한다.
![[Pasted image 20240414180131.png]]
중위 순회 결과: D-B-E-A-F-C-G

## 후위 순회 (Postorder Traversal)

### 용도
- 트리 삭제하는 데 주로 사용됨
	- 부모노드를 삭제하기 전에 자식노드를 삭제하는 순으로 노드를 삭제해야 하기 때문!

### 과정
1. 왼쪽 서브트리를 후위순회
2. 오른쪽 서브트리를 후위순회
3. Root 노드를 방문
![[Pasted image 20240414180303.png]]
후위순회 결과: D-E-B-F-G-C-A

## 이진 탐색 트리 (BST, Binary Search Tree)

## AVL 트리 (AVL Tree)

## 다원 탐색 트리 (Multiway Search Tree)

## 힙 (Heap), 이진 힙 (Binary heap)




# 6. 그래프 (Graph)




# 참고문헌
[블로그](https://yoongrammer.tistory.com/category/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%20%28Data%20structure%29?page=1])

